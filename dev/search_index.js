var documenterSearchIndex = {"docs":
[{"location":"aladin/#ALADIN","page":"ALADIN","title":"ALADIN","text":"","category":"section"},{"location":"aladin/","page":"ALADIN","title":"ALADIN","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"aladin/","page":"ALADIN","title":"ALADIN","text":"solve_dopf_aladin_coordinated","category":"page"},{"location":"aladin/#PowerModelsADA.solve_dopf_aladin_coordinated","page":"ALADIN","title":"PowerModelsADA.solve_dopf_aladin_coordinated","text":"solve_dopf_aladin_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level = true, p::Real=1000, mu::Real=1000, p_upper::Real=1e6, mu_upper::Real=2e6, r_p::Real=1.5, mu_p::Real=2, a1::Real=1, a2::Real=1, #     a3::Real=1, q_gamma::Real=0, sigma::Dict{String,Real}=Dict())\n\nSolve the distributed OPF problem using ALADIN algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \np::Real=1000 : parameter\nmu::Real=1000 : parameter\np_upper::Real=1e6 : parameter\nmu_upper::Real=2e6 : parameter\nr_p::Real=1.5 : parameter\nr_mu::Real=2 : parameter\na1::Real=1 : parameter\na2::Real=1 : parameter\na3::Real=1 : parameter\nq_gamma::Real=0 : parameter\nsigma::Dict{String, <:Any}=Dict() : dictionary with variable name as key and parameter value as values\n\n\n\n\n\n","category":"function"},{"location":"aladin/","page":"ALADIN","title":"ALADIN","text":"Modules = [PowerModelsADA.aladin_coordinated_methods]","category":"page"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.build_method_local","text":"build PowerModel object for the ALADIN algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.initialize_method_coordinator","text":"initialize the ALADIN algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.initialize_method_local","text":"initialize the ALADIN algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.objective_aladin_local-Tuple{AbstractPowerModel}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.objective_aladin_local","text":"ALADIN algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.solve_coordinator!-Tuple{Any, Any}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.solve_coordinator!","text":"solve the ALADIN algorithm coordinator problem\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.update_method_coordinator","text":"update the ALADIN algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s174\"} where var\"#s174\"}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.update_method_local","text":"update the ALADIN algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"comparison/#Comparison-Results","page":"Comparison Results","title":"Comparison Results","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"The results of using PowerModelsADAv0.1 on 9 test cases from PGLib-OPF is shown here. We benchmark three distributed algorithms with 5 power flow formulations.","category":"page"},{"location":"comparison/#Simulation-Setup","page":"Comparison Results","title":"Simulation Setup","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"We run the three distributed algorithms on a high-performance computing service with a 16-core CPU and 16GB of RAM. We produced the results shown here using PowerModelsADA v0.1 in Julia v1.6. We use Ipopt solver for the polar and rectangular ACOPF and Gurobi for the DC approximation, and SOCP and QC relaxations of the OPF.","category":"page"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"We report the results that achieved the l_2-norm of the mismatches less than 0.01 (radians and per unit) within 10,000 iterations and the absolute value of the relative error less than 1% of the central solution from PowerModels.jl.","category":"page"},{"location":"comparison/#Polar-Form-ACOPF","page":"Comparison Results","title":"Polar Form ACOPF","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 0.45 16 0.78 27 0.82 31\n24_ieee_rts 4 8.09 100 4.56 66 10.80 142\n30_ieee 3 1.17 23 1.39 27 1.56 31\n30pwl 3 1.40 23 3.42 53 1.73 26\n39_epri 3 8.09 89 625.31 198 7.81 94\n73_ieee_rts 3 11.39 61 10.74 53 13.52 70\n179_goc 3 33.44 66 363.90 110 72.02 163\n300_ieee 4 40.33 99 40.25 82 36.15 76\n588_sdet 8 1818.97 1877 660.10 625 1280.41 1278","category":"page"},{"location":"comparison/#Rectangular-Form-ACOPF","page":"Comparison Results","title":"Rectangular Form ACOPF","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 0.61 19 1.22 28 1.06 32\n24_ieee_rts 4 15.29 133 9.10 77 20.36 205\n30_ieee 3 1.91 27 2.40 33 1.55 23\n30pwl 3 3.28 42 5.27 62 4.57 58\n39_epri 3 50.77 397 NC NC 10.17 94\n73_ieee_rts 3 24.94 111 18.92 62 25.23 115\n179_goc 3 93.58 165 32.17 45 86.78 169\n300_ieee 4 40.20 73 82.60 94 47.26 92\n588_sdet 8 1538.00 1337 NC NC 1366.12 1180","category":"page"},{"location":"comparison/#DC-Approximation","page":"Comparison Results","title":"DC Approximation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 0.10 14 0.23 34 1.13 20\n24_ieee_rts 4 3.79 204 1.67 62 3.71 198\n30_ieee 3 0.18 21 0.35 45 0.27 35\n30pwl 3 0.18 22 0.34 42 0.16 19\n39_epri 3 1.21 71 6.181 69 1.38 63\n73_ieee_rts 3 2.16 74 2.26 68 2.53 78\n179_goc 3 2.85 61 1.01 26 1.94 43\n300_ieee 4 2.38 37 4.73 59 2.43 35\n588_sdet 8 102.48 1168 18.535 655 89.58 1155","category":"page"},{"location":"comparison/#SOCP-Relaxation","page":"Comparison Results","title":"SOCP Relaxation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 0.49 15 0.76 31 0.75 17\n24_ieee_rts 4 2.81 52 2.55 35 3.15 51\n30_ieee 3 0.47 11 1.35 33 1.46 25\n30pwl 3 0.55 11 2.61 46 1.27 15\n39_epri 3 9.53 105 3.92 72 7.42 117\n73_ieee_rts 3 0.16 2 1.52 22 0.19 2\n179_goc 3 3.37 19 3.78 23 5.44 35\n300_ieee 4 11.04 25 20.11 52 8.93 18\n588_sdet 8 3381.35 5000 44.55 79 3177.05 5000","category":"page"},{"location":"comparison/#QC-Relaxation","page":"Comparison Results","title":"QC Relaxation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 0.64 18 0.75 23 0.46 14\n24_ieee_rts 4 5.47 58 3.62 53 5.57 65\n30_ieee 3 0.88 14 1.43 33 1.99 26\n30pwl 3 1.96 39 5.36 79 1.22 12\n39_epri 3 15.74 195 NC 1000 10.63 102\n73_ieee_rts 3 2.04 6 NC 1000 1.17 6\n179_goc 3 30.46 44 60.45 63 20.83 39\n300_ieee 4 63.74 34 NC 1000 54.44 26\n588_sdet 8 478.99 184 220.44 102 455.58 177","category":"page"},{"location":"app/#APP","page":"APP","title":"APP","text":"","category":"section"},{"location":"app/","page":"APP","title":"APP","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"app/","page":"APP","title":"APP","text":"solve_dopf_app","category":"page"},{"location":"app/#PowerModelsADA.solve_dopf_app","page":"APP","title":"PowerModelsADA.solve_dopf_app","text":"solve_dopf_app(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\",tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, alpha::Real=1000, beta::Real, gamma::Real)\n\nSolve the distributed OPF problem using APP algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1000 : algorithm parameter\nbeta::Real=2alpha : algorithm parameter\ngamma::Real=alpha : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"app/","page":"APP","title":"APP","text":"Modules = [PowerModelsADA.app_methods]","category":"page"},{"location":"app/#PowerModelsADA.app_methods","page":"APP","title":"PowerModelsADA.app_methods","text":"APP algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"app/#PowerModelsADA.app_methods.build_method-Tuple{AbstractPowerModel}","page":"APP","title":"PowerModelsADA.app_methods.build_method","text":"build PowerModel object for the APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.initialize_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", Type}","page":"APP","title":"PowerModelsADA.app_methods.initialize_method","text":"initialize the APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.objective_app-Tuple{AbstractPowerModel}","page":"APP","title":"PowerModelsADA.app_methods.objective_app","text":"APP algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.solve_method-Tuple{Any, DataType, Any}","page":"APP","title":"PowerModelsADA.app_methods.solve_method","text":"solve distributed OPF using APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"APP","title":"PowerModelsADA.app_methods.update_method","text":"update the APP algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [PowerModelsADA]\nPages   = [\"base.jl\", \"data.jl\", \"data_sharing.jl\", \"opf.jl\", \"util.jl\", \"variables.jl\"]","category":"page"},{"location":"library/#PowerModelsADA.calc_dual_residual!-Tuple{Dict{String, var\"#s50\"} where var\"#s50\"}","page":"Library","title":"PowerModelsADA.calc_dual_residual!","text":"calc_dual_residual!(data::Dict{String, <:Any}; central::Bool=false)\n\ncalculate the dual redidual as seen by the area. Set central=true if the algorithm uses the optimality condition of a central coordinator.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_global_mismatch-Tuple{Dict{Int64, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.calc_global_mismatch","text":"calculate the global mismatch based on local mismatch\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_mismatch!-Tuple{Dict{String, var\"#s48\"} where var\"#s48\"}","page":"Library","title":"PowerModelsADA.calc_mismatch!","text":"calc_mismatch!(data::Dict{String, <:Any}; central::Bool=false)\n\ncalculate the mismatch and return the area data dictionary with the mismatch as seen by the area. Set central=true if the algorithm uses the optimality condition of a central coordinator.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.flag_convergance-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.flag_convergance","text":"check flag convergance using mismatch and dual residual\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.initialize_dopf!-Tuple{Dict{String, var\"#s53\"} where var\"#s53\", DataType}","page":"Library","title":"PowerModelsADA.initialize_dopf!","text":"initialize dopf parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.print_convergence-Tuple{Dict, Int64}","page":"Library","title":"PowerModelsADA.print_convergence","text":"print final solution status\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.print_iteration","page":"Library","title":"PowerModelsADA.print_iteration","text":"print iteration information\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.save_solution!-Tuple{Dict{String, var\"#s55\"} where var\"#s55\"}","page":"Library","title":"PowerModelsADA.save_solution!","text":"save last solution in previous_solutions vector\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf-Tuple{Dict{String, var\"#s6\"} where var\"#s6\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf","text":"solve_dopf(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmultiprocessors::Bool=false : enable multiprocessors using available workers. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated-Tuple{Dict{String, var\"#s49\"} where var\"#s49\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated","text":"solve_dopf_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmultiprocessors::Bool=false : enable multiprocessors using available workers. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated_mp-Tuple{Dict{Int64, var\"#s6\"} where var\"#s6\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated_mp","text":"solve_dopf_coordinated_mp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator on multiprocessors. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated_sp-Tuple{Dict{Int64, var\"#s5\"} where var\"#s5\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated_sp","text":"solve_dopf_coordinated_sp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator on single-processors.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_mp-Tuple{Dict{Int64, var\"#s5\"} where var\"#s5\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_mp","text":"solve_dopf_mp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm on multiprocessors. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\n\nArguments:\n\ndata::Dict{Int64, <:Any} : dictionary contains area data in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_sp-Tuple{Dict{Int64, var\"#s50\"} where var\"#s50\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_sp","text":"solve_dopf_sp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm on single-processor.\n\nArguments:\n\ndata::Dict{Int64, <:Any} : dictionary contains area data in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_flag_convergence!-Tuple{Dict{String, var\"#s50\"} where var\"#s50\"}","page":"Library","title":"PowerModelsADA.update_flag_convergence!","text":"check the shared variables of a local area are within tol\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_global_flag_convergence-Tuple{Dict, Dict, Float64, String}","page":"Library","title":"PowerModelsADA.update_global_flag_convergence","text":"check the flag convergence for all areas and return a global variables\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_global_flag_convergence-Tuple{Dict{Int64, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.update_global_flag_convergence","text":"check the flag convergence for all areas and return a global variables\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_iteration!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.update_iteration!","text":"update iteration\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_shared_variable!-Tuple{AbstractPowerModel, Dict{String, var\"#s53\"} where var\"#s53\"}","page":"Library","title":"PowerModelsADA.update_shared_variable!","text":"update primal variables after obtaining a solution at each iteraton\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_solution!-Tuple{AbstractPowerModel, Dict{String, var\"#s54\"} where var\"#s54\"}","page":"Library","title":"PowerModelsADA.update_solution!","text":"update the area data solution dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.add_virtual_gen-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", Vector{T} where T, Int64}","page":"Library","title":"PowerModelsADA.add_virtual_gen","text":"add virtual generators at the neighboring buses of an area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.arrange_areas_id!-Tuple{Dict{String, var\"#s177\"} where var\"#s177\"}","page":"Library","title":"PowerModelsADA.arrange_areas_id!","text":"arrange area ID from 1 to number of areas. This step is necessary when having area number 0 and using central coordinator\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", Matrix{Int64}}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a matrix with [bus, area] columnsor rows\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", String}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a CVS file with buses and area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", Vector{Pair{Int64, Int64}}}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a vector with (bus => area) pairs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s55\"} where var\"#s55\", Dict}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a dictionary with (bus => area) Int pairs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_coordinator-Tuple{Dict{String, var\"#s171\"} where var\"#s171\"}","page":"Library","title":"PowerModelsADA.decompose_coordinator","text":"obtain system coordinator data\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_system-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.decompose_system","text":"decompose_system(data::Dict{String, <:Any})\n\ndecompose a system into areas defined by bus area.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_system-Tuple{Dict{String, var\"#s180\"} where var\"#s180\", Int64}","page":"Library","title":"PowerModelsADA.decompose_system","text":"obtain an area decomposition with area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_area_id-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_area_id","text":"helper function to get the area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_area_id-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_area_id","text":"helper function to get the area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_bus-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_areas_bus","text":"helper functions to all areas buses in a dicrionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_bus-Tuple{Dict{String, var\"#s172\"} where var\"#s172\"}","page":"Library","title":"PowerModelsADA.get_areas_bus","text":"helper functions to all areas buses in a dicrionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{Dict{Int64, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{Dict{String, var\"#s177\"} where var\"#s177\"}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_local_bus-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_local_bus","text":"helper functions to get the area's local buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_local_bus-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", Int64}","page":"Library","title":"PowerModelsADA.get_local_bus","text":"helper functions to get the area's local buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{AbstractPowerModel, Vector{T} where T}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", Vector{T} where T}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", Int64}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{Dict{String, var\"#s54\"} where var\"#s54\", Int64}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between an area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.prepare_shared_data-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", Int64}","page":"Library","title":"PowerModelsADA.prepare_shared_data","text":"prepare the shared data with or without serialization\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.receive_shared_data!-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", Dict{String, var\"#s176\"} where var\"#s176\", Int64}","page":"Library","title":"PowerModelsADA.receive_shared_data!","text":"store received data in the local data dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.receive_shared_data!-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", Vector{T} where T, Int64}","page":"Library","title":"PowerModelsADA.receive_shared_data!","text":"deserialize and store the received data in the local data\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.constraint_opf-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.constraint_opf","text":"define OPF problem constraints\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.no_objective-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.no_objective","text":"no objective function case\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.objective_min_fuel_and_consensus!","page":"Library","title":"PowerModelsADA.objective_min_fuel_and_consensus!","text":"define objective function using PowerModels and algorithm-specific objective\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.variable_opf-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.variable_opf","text":"define OPF problem variable\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_dist_gen_cost-Tuple{Dict{Int64, var\"#s178\"} where var\"#s178\"}","page":"Library","title":"PowerModelsADA.calc_dist_gen_cost","text":"calculate distributed solution operation cost\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_number_all_variables-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", DataType}","page":"Library","title":"PowerModelsADA.calc_number_all_variables","text":"get the number of variables in an area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_number_areas_variables-Tuple{Dict{String, var\"#s178\"} where var\"#s178\", DataType}","page":"Library","title":"PowerModelsADA.calc_number_areas_variables","text":"get the number of variables in each area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_number_shared_variables-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", DataType}","page":"Library","title":"PowerModelsADA.calc_number_shared_variables","text":"get the number of shared variable in a area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_number_system_shared_variables-Tuple{Dict{String, var\"#s178\"} where var\"#s178\", DataType}","page":"Library","title":"PowerModelsADA.calc_number_system_shared_variables","text":"get the number of shared variable in all area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_number_variables-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"Library","title":"PowerModelsADA.calc_number_variables","text":"get the number of variables\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.compare_solution-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", Dict{Int64, var\"#s176\"} where var\"#s176\", DataType, Any}","page":"Library","title":"PowerModelsADA.compare_solution","text":"compare the distributed algorithm solution with PowerModels centralized solution\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.partition_system!-Tuple{Dict, Int64}","page":"Library","title":"PowerModelsADA.partition_system!","text":"partition_system!(data::Dict, n::Int64; configuration::Symbol=:edge_cut, print_info::Bool=false)\n\nPartition a system into n areas using KaHyPar partition algorithm\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nn::Int : number of areas\nconfiguration::Symbol=:edgecut : partition meteric (:edgecut or :connectivity)\nprint_info::Bool=false : print partition algorithm information\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA._var-Tuple{AbstractPowerModel, String, String}","page":"Library","title":"PowerModelsADA._var","text":"return JuMP variable object from PowerModel object\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.initial_value","page":"Library","title":"PowerModelsADA.initial_value","text":"initial_value(variable::String, initialization_method::String=\"flat\")\n\nassign initial value based on initialization method\n\nArguments:\n\nvariable::String : variable names\ninitializationmethod::String=\"flat : (\"flat\", \"previoussolution\")\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.initialize_all_variable","page":"Library","title":"PowerModelsADA.initialize_all_variable","text":"initialize_all_variable(data::Dict{String, <:Any}, model_type::DataType, dics_name::String=\"solution\", initialization_method::String=\"flat\")\n\nreturn a dictionary contains all the problem variables. can be used to store the solutions.\n\nArguments:\n\ndata::Dict{String, <:Any} : area data\nmodel_type::DataType : power flow formulation (PowerModel type)\ndics_name::String=\"solution\" : location of existing dicrionary to be used to worm start the output\ninitialization_method::String=\"flat\" : \"flat\" or \"worm\" initialization\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.initialize_shared_variable","page":"Library","title":"PowerModelsADA.initialize_shared_variable","text":"initialize shared variable dictionary\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.variable_names-Tuple{DataType}","page":"Library","title":"PowerModelsADA.variable_names","text":"identifyall the variables names\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.variable_shared_names-Tuple{DataType}","page":"Library","title":"PowerModelsADA.variable_shared_names","text":"identifythe shared bus and branch variables names\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"To solve the OPF problem using the ADMM use the solve function run_dopf_admm. The solve function stores the result in a data dictionary contains subsystems information.","category":"page"},{"location":"quickguide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerModelsADA\nusing Ipopt\n\nmodel_type = ACPPowerModel\nresult = run_dopf_admm(\"test/data/case_RTS.m\", model_type, Ipopt.Optimizer; print_level=1)","category":"page"},{"location":"newalgorithm/#User-Defined-Algorithm","page":"User-defined Algorithm","title":"User-Defined Algorithm","text":"","category":"section"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"To define a new algorithm, we need to define a module for the new algorithm that contains the main solve function in addition to three algorithm-specific functions. The three algorithm-specific are: initialize, build, and update. You can follow the exmaple in the template file.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The module of xx algorithm should be defined and exported as xx_methods as follows:","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"\"\"\ntemplate for xx distributed algorithm\n\"\"\"\nmodule xx_methods\nusing ..PowerModelsADA\n\n### functions ###\n\n# export the algorithm methods module and call method\nexport xx_methods, solve_dopf_xx","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The solve function is the main method to use the xx algorithm. The function takes the data, power flow formulation (model_type), JuMP solver object, and algorithm's parameters as required. The solve function should use the pre-defined algorithm flow as follows:  ","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"solve distributed OPF using XX algorithm\"\nfunction solve_method(data, model_type::DataType, optimizer; \n    mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \n    verbose::Int64=1, parameters...)\n\n    solve_dopf(data, model_type, optimizer, xx_methods; \n    mismatch_method=mismatch_method, tol=tol, max_iteration=max_iteration, \n    verbose=verbose, parameters...)\nend","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The first algorithm-specific function is the initialize function. The function takes the area data file and adds to it the required parameters, counters, and shared variables. There are multiple built-in functions in PowerModelsADA that can be used to define the shared and received variables, as well as the dual variables. Note that the initialization function should include the initialize_dopf! to define the counters and convergence flags.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"initialize the XX algorithm\"\nfunction initialize_method(data::Dict{String, <:Any}, model_type::Type; tol::Float64=1e-4, max_iteration::Int64=1000, kwargs...)\n\n    # initiate primal and dual shared variables\n    data[\"shared_variable\"] = Dict(to_area=> variable_name=>value)\n    data[\"received_variable\"] = Dict(from_area=> variable_name=>value)\n\n    # distributed algorithm settings\n    initialize_dopf!(data, model_type; kwargs...)\n\n    # xx parameters\n    data[\"parameter\"] = Dict(\"alpha\"=> get(kwargs, :alpha, 1000))\n\nend","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The second function is the build function, which builds the PowerModels object of the subproblem. The subproblems typically have the same variables and constraints as the central OPF problem and differ in the objective functions. To build a subproblem with the same variables and constraints as the central OPF problem with a specific objective function, we need to define the objective function using the template shown below. The objective function definition takes the PowerModels object and returns a JuMP expression. You can use the internal helper function _var to obtain the JuMP model variables' object defined in the PowerModels object.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"build PowerModel using xx algorithm\"\nfunction build_method(pm::AbstractPowerModel)\n\n    # define variables\n    variable_opf(pm)\n\n    # define constraints\n    constraint_opf(pm)\n  \n    # define objective function\n    objective_min_fuel_and_consensus!(pm, objective_function)\nend\n\n\"set the xx algorithm objective\"\nfunction objective_function(pm::AbstractPowerModel)\n\n    # to get the JuMP object of the active power of generator 1 use:\n    pg1 = _var(pm, :pg, 1)\n\n    ###\n    objective = pg1\n    ###\n    return objective\nend","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"_var","category":"page"},{"location":"newalgorithm/#PowerModelsADA._var","page":"User-defined Algorithm","title":"PowerModelsADA._var","text":"return JuMP variable object from PowerModel object\n\n\n\n\n\n","category":"function"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The last function is to update the area dictionary after communicating the shared variables results with other areas.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"update the xx algorithm before each iteration\"\nfunction update_method(data::Dict{String, <:Any})\n\n    ###\n\n    ###\nend\n","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"This is a general way to define a distributed algorithm that is fully distributed with the same main algorithm flow as the pre-defined algorithms. For other algorithm flows, the solve function needs to be defined fully instead of using the pre-define function solve_dopf.","category":"page"},{"location":"specification/#Technical-Specifications","page":"Technical Specifications","title":"Technical Specifications","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Power-Flow-Formulation","page":"Technical Specifications","title":"Power Flow Formulation","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Optimization-Solver","page":"Technical Specifications","title":"Optimization Solver","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Distributed-Algorithm","page":"Technical Specifications","title":"Distributed Algorithm","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"atc/#ATC","page":"ATC","title":"ATC","text":"","category":"section"},{"location":"atc/","page":"ATC","title":"ATC","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"atc/","page":"ATC","title":"ATC","text":"solve_dopf_atc\nsolve_dopf_atc_coordinated","category":"page"},{"location":"atc/#PowerModelsADA.solve_dopf_atc","page":"ATC","title":"PowerModelsADA.solve_dopf_atc","text":"solve_dopf_atc(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level = true, print_optimizer_info::Bool=false, alpha::Real=1000, beta::Real = 1)\n\nSolve the distributed OPF problem using ATC algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1.05 : algorithm parameter\nbeta::Real=1.0 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"atc/#PowerModelsADA.solve_dopf_atc_coordinated","page":"ATC","title":"PowerModelsADA.solve_dopf_atc_coordinated","text":"solve_dopf_atc_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level = true, alpha::Real=1000)\n\nSolve the distributed OPF problem using ATC algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1.05 : algorithm parameters\nbeta::Real=1.0 : algorithm parameters\n\n\n\n\n\n","category":"function"},{"location":"atc/","page":"ATC","title":"ATC","text":"Modules = [PowerModelsADA.atc_methods, PowerModelsADA.atc_coordinated_methods]","category":"page"},{"location":"atc/#PowerModelsADA.atc_methods","page":"ATC","title":"PowerModelsADA.atc_methods","text":"ATC algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"atc/#PowerModelsADA.atc_methods.build_method-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_methods.build_method","text":"build PowerModel object for the ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.initialize_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_methods.initialize_method","text":"initialize the ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.objective_atc-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_methods.objective_atc","text":"ATC algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.solve_method-Tuple{Any, DataType, Any}","page":"ATC","title":"PowerModelsADA.atc_methods.solve_method","text":"solve distributed OPF using ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ATC","title":"PowerModelsADA.atc_methods.update_method","text":"update the ATC algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods","text":"ATC algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.build_method_coordinator-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.build_method_coordinator","text":"build PowerModel object for the ATC algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.build_method_local","text":"build PowerModel object for ATC algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.initialize_method_coordinator","text":"initialize the ATC algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.initialize_method_local","text":"initialize the ATC algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.objective_atc_coordinator-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.objective_atc_coordinator","text":"ATC algorithm objective function of the local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.objective_atc_local-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.objective_atc_local","text":"ATC algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.solve_method-Tuple{Any, DataType, Any}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.solve_method","text":"solve distributed OPF using ATC algorithm with central coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.update_method_coordinator","text":"update the ATC algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.update_method_local","text":"update the ATC algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#ADMM","page":"ADMM","title":"ADMM","text":"","category":"section"},{"location":"admm/","page":"ADMM","title":"ADMM","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"admm/","page":"ADMM","title":"ADMM","text":"solve_dopf_admm\nsolve_dopf_admm_coordinated","category":"page"},{"location":"admm/#PowerModelsADA.solve_dopf_admm","page":"ADMM","title":"PowerModelsADA.solve_dopf_admm","text":"solve_dopf_admm(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, print_optimizer_info::Bool=false, alpha::Real=1000)\n\nSolve the distributed OPF problem using ADMM algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"admm/#PowerModelsADA.solve_dopf_admm_coordinated","page":"ADMM","title":"PowerModelsADA.solve_dopf_admm_coordinated","text":"solve_dopf_admm_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level::Int64=1, alpha::Real=1000)\n\nSolve the distributed OPF problem using ADMM algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameters\n\n\n\n\n\n","category":"function"},{"location":"admm/","page":"ADMM","title":"ADMM","text":"Modules = [PowerModelsADA.admm_methods, PowerModelsADA.admm_coordinated_methods]","category":"page"},{"location":"admm/#PowerModelsADA.admm_methods","page":"ADMM","title":"PowerModelsADA.admm_methods","text":"ADMM algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"admm/#PowerModelsADA.admm_methods.build_method-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_methods.build_method","text":"build PowerModel object for the ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.initialize_method-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ADMM","title":"PowerModelsADA.admm_methods.initialize_method","text":"initialize the ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.objective_admm-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_methods.objective_admm","text":"ADMM algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.solve_method-Tuple{Any, DataType, Any}","page":"ADMM","title":"PowerModelsADA.admm_methods.solve_method","text":"solve distributed OPF using ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ADMM","title":"PowerModelsADA.admm_methods.update_method","text":"update the ADMM algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods","text":"ADMM algorithm module containsbuild and update methods\n\n\n\n\n\n","category":"module"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.build_method_coordinator-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.build_method_coordinator","text":"build PowerModel object for the ADMM algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.build_method_local","text":"build PowerModel object for the ADMM algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.initialize_method_coordinator","text":"initializethe ADMM algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.initialize_method_local","text":"initialize the ADMM algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.objective_admm_coordinator-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.objective_admm_coordinator","text":"ADMM algorithm objective function of the local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.objective_admm_local-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.objective_admm_local","text":"ADMM algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.solve_method-Tuple{Any, DataType, Any}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.solve_method","text":"solve distributed OPF using ADMM algorithm with central coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.update_method_coordinator","text":"update the ADMM algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.update_method_local","text":"update the ADMM algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"data_structure/#Data-Structure","page":"Data Structure","title":"Data Structure","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"data_structure/#Input-Data","page":"Data Structure","title":"Input Data","text":"","category":"section"},{"location":"data_structure/#Case","page":"Data Structure","title":"Case","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"PowerModelsADA uses a dictionary of dictionaries to store the case data and the subproblem data. The case data dictionary is similar to the one in PowerModels with area assignment for each bus. The buses in the data dictionary must contain an area key with more than one distinct area ID. The subproblem data is similar to the case data with additional information. The area data contains the area-specific data and the distributed algorithm parameters.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To load a data file, we use parse_file function as follow:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"case_path = \"test/data/case14.m\"\ndata = parse_file(case_path)","category":"page"},{"location":"data_structure/#Partitioning","page":"Data Structure","title":"Partitioning","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To check the areas ID in a data dictionary, use get_areas_id(data) to get all areas' IDs in data. If the data dictionary doesn't contain more than one area, we can partition the system manually using assign_area! function or using the partitioning algorithm in KaHyPar.jl via partition_system! function. An example of partition file is shown in partition example.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"assign_area!\npartition_system!","category":"page"},{"location":"data_structure/#PowerModelsADA.assign_area!","page":"Data Structure","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a dictionary with (bus => area) Int pairs\n\n\n\n\n\nassign area to the system data using a CVS file with buses and area ID\n\n\n\n\n\nassign area to the system data using a vector with (bus => area) pairs\n\n\n\n\n\nassign area to the system data using a matrix with [bus, area] columnsor rows\n\n\n\n\n\n","category":"function"},{"location":"data_structure/#PowerModelsADA.partition_system!","page":"Data Structure","title":"PowerModelsADA.partition_system!","text":"partition_system!(data::Dict, n::Int64; configuration::Symbol=:edge_cut, print_info::Bool=false)\n\nPartition a system into n areas using KaHyPar partition algorithm\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nn::Int : number of areas\nconfiguration::Symbol=:edgecut : partition meteric (:edgecut or :connectivity)\nprint_info::Bool=false : print partition algorithm information\n\n\n\n\n\n","category":"function"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"Before running the distributed algorithm, PowerModelsADA internally decomposes the original system into subsystems using decompose_system function. the function decouples the tie-lines between two areas by introducing dummy buses and virtual generators at the tie-lines' ends.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"decompose_system","category":"page"},{"location":"data_structure/#PowerModelsADA.decompose_system","page":"Data Structure","title":"PowerModelsADA.decompose_system","text":"decompose_system(data::Dict{String, <:Any})\n\ndecompose a system into areas defined by bus area.\n\n\n\n\n\nobtain an area decomposition with area ID\n\n\n\n\n\n","category":"function"},{"location":"data_structure/#Output-Data","page":"Data Structure","title":"Output Data","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"The output of the distributed algorithms is stored in a dictionary. The dictionary's keys are the areas ID, and the dictionary's values are the areas data dictionary with the results stored in solution dictionary.","category":"page"},{"location":"data_structure/#Saving-Iterations-Data","page":"Data Structure","title":"Saving Iterations Data","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To save a specific data during the distributed algorithm (e.g., store the \"shared_variable\" dictionary each iteration), use the option save_data::Vector{String}=[] in the solve function and add the key of the data (e.g., save_data=[\"shared variable\"]). The output of the solve function will contain a dictionary with a key called \"previous_solution\" that contains vectors of the selected saved data ordered by the iteration number.","category":"page"},{"location":"data_structure/#Generation-Cost","page":"Data Structure","title":"Generation Cost","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To calculate the objective function of the central algorithm use calc_dist_gen_cost.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"calc_dist_gen_cost","category":"page"},{"location":"data_structure/#PowerModelsADA.calc_dist_gen_cost","page":"Data Structure","title":"PowerModelsADA.calc_dist_gen_cost","text":"calculate distributed solution operation cost\n\n\n\n\n\n","category":"function"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To compare the distributed algorithm objective function value with the central OPF, use compare_solution to get the absolute value of the relative error.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"compare_solution","category":"page"},{"location":"data_structure/#PowerModelsADA.compare_solution","page":"Data Structure","title":"PowerModelsADA.compare_solution","text":"compare the distributed algorithm solution with PowerModels centralized solution\n\n\n\n\n\n","category":"function"},{"location":"#PowerModelsADA.jl","page":"Home","title":"PowerModelsADA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PowerModelsADA","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA.jl (Power Models Alternating Distributed Algorithms) provides a framework to solve Optimal Power Flow (OPF) problems using alternating distributed algorithms. The package allows to use different distributed algorithms. PowerModelsADA is built on top of PowerModels.jl and JuMP.jl to model and solve the subproblems.","category":"page"},{"location":"#Distributed-Algorithms","page":"Home","title":"Distributed Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PowerModelsADA framework is designed to easily incorporate new alternating distributed algorithms. The framework provides means to decompose a test case into multiple areas, model the subproblems associated with each area using PowerModels, solve the supropblems in parallel using multi-threading, communicate the shared data between the areas, and calculate the mismatches to decide if the termination criteria are satisfied.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current version of PowerModelsADA implements four distributed algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternating Direction Method of Multipliers (ADMM)\nAnalytical Target Cascading (ATC)\nAuxiliary Problem Principle (APP)\nAugmented Lagrangian Alternating Direction Inexact Newton (ALADIN)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA can be extended to include variations of the existing algorithms or new user-defined algorithms. More details about the formulations and algorithm implementations are shown in Technical Specifications","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"PowerModelsADA\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example demonstrating how to code up and solve the OPF problem with distributed algorithms is found in Quick Start Guide section of the documentation.","category":"page"},{"location":"tutorial/#Tutorial","page":"Using PowerModelsADA","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"PowerModelsADA solves OPF problems using either a pre-defined distributed algorithm or a user-defined algorithm. This page shows examples of solving the OPF problem using the pre-defined algorithms and how to define a new alternating distributed algorithm.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"The distributed algorithm-specific functions are stored in modules. Each module contains at least three main functions: initialization, building, and update functions. Each module contains a solve function that solves the OPF by passing the case, solver, and power flow model.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"The distributed algorithm module and solve function are:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"ADMM: modules: admm_methods and admm_coordinated_methods. solve functions: solve_dopf_admm and solve_dopf_admm_coordinated\nATC: modules: atc_methods and atc_coordinated_methods. solve functions: solve_dopf_atc and solve_dopf_atc_coordinated\nAPP: modules: app_methods. solve functions: solve_dopf_app\nALADIN: modules: aladin_coordinated_methods. solve function: solve_dopf_aladin_coordinated","category":"page"},{"location":"tutorial/#Run-Distributed-Algorithm","page":"Using PowerModelsADA","title":"Run Distributed Algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To solve the OPF problem, we need first to import the PowerModelsADA package and an optimization solver. In this case we use the NLP solver Ipopt. You can install the solver using using Pkg, Pkg.add(\"Ipopt\"). Then run the following code while you are inside the PowerModelsADA package directory.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"## Import package\nusing PowerModelsADA\nusing Ipopt ","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"Next, we need to upload a test case. We will use IEEE 14-bus system in /test/data/ folder in MATPOWER format. The file can be loaded using parse_file from PowerModels package. The test system needs to be divided into multiple distinct areas. This can be checked by looking into data[\"bus\"][bus_id][\"area\"]. If not, you can use partition_system! function to divide the system or load a csv file contains the buses and area of each bus.  ","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"\n## Read case with partition file and return dictionary of the partitioned case\ncase_path = \"test/data/case14.m\"\npartition_file_path = \"test/data/case14_2areas.csv\"\ndata = parse_file(case_path)\nassign_area!(data, partition_file_path)\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"Now, the case study is loaded and ready to be used to solve the OPF problem using distributed algorithms. We first need to define parameters, load the solver, and select a power flow formulation model_type as follows:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"\n## Settings and optimizer initiation\nmax_iteration = 1000\ntol = 1e-4\nalpha = 1000\noptimizer = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\"=>0)\n\n##  Power Flow Model selection\nmodel_type = DCPPowerModel\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To solve the OPF problem using ADMM algorithm using the solve function, we use the following code:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"data_area = solve_dopf_admm(data, model_type, optimizer, tol=tol, max_iteration=max_iteration, verbose = false, alpha=alpha)\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To compare the distributed algorithm objective function value with the central OPF, use compare_solution to get the absolute value of the relative error.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"error_admm = compare_solution(data, data_area, model_type, optimizer)\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"PowerModelsADA also provides the flexibility for more granular control of the distributed algorithm. We can use the following code to initialize the distributed algorithm (we use ADMM in this example).","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"\n## define parameters and power flow model\nmax_iteration = 1000\ntol = 1e-4\nalpha = 1000\nmodel_type = DCPPowerModel\n\n## obtain areas idx\nareas_id = get_areas_id(data)\n\n## decompose the system into subsystems\ndata_area = decompose_system(data)\n\n## initialize parameters using the algorithm-specific initialize function\nfor i in areas_id\n    admm_methods.initialize_method(data_area[i], model_type; tol=tol, max_iteration=max_iteration, alpha = alpha)\nend\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"We then start the iterative process of the distributed algorithm using while loop with a pre-define termination criteria as follows:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"## initialize global counters\niteration = 0\nflag_convergence = false\n\n## start iteration\nwhile iteration < max_iteration && flag_convergence == false\n\n    ## solve local problem and update solution\n    for i in areas_id\n        result = solve_model(data_area[i], model_type, optimizer, admm_methods.build_method, solution_processors=admm_methods.post_processors)\n        update_data!(data_area[i], result[\"solution\"])\n    end\n\n    ## share solution with neighbors\n    for i in areas_id # sender subsystem\n        for j in data_area[i][\"neighbors\"] # receiver subsystem\n            shared_data = prepare_shared_data(data_area[i], j)\n            receive_shared_data!(data_area[j], deepcopy(shared_data), i)\n        end\n    end\n\n    # calculate mismatches and update convergence flags\n    for i in areas_id\n        dopf_method.update_method(data_area[i])\n    end\n\n    ## check global convergence and update iteration counters\n    flag_convergence = update_global_flag_convergence(data_area)\n    iteration += 1\nend\n","category":"page"}]
}
